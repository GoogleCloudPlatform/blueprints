# CSR Git Ops Pipeline
## Author:
jcwc@

[TOC]

## Prerequisites:
- Yakima cluster (set as current-context for kubectl)
- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
  - Installed and contains context for Yakima cluster
- [kpt](https://googlecontainertools.github.io/kpt/guides/)

## Description:
This blueprint instantiates a Git Ops CI/CD pipeline using Cloud Source Repositories and Cloud Build. After installing this blueprint, you will be able to:
1. Manage your infrastructure via version control.
2. Create merge requests to review changes
3. Manage plain KRM or blueprints and specify kpt functions for Cloud Build to use to hydrate/ validate your configs
4. Automatically apply your git repo configs to your Yakima cluster on merge
<!-- ... insert more as needed. -->

The components generated by this blueprint include:
- [Config Sync](https://cloud.google.com/kubernetes-engine/docs/add-on/config-sync/overview) w/ gcenode secret configured
 - This allows Yakima to apply KRM directly from the deployment repo to the Yakima cluster.

- Source repo (DRY)
  - This is where your changes will be made. You can push plain KRM or [blueprints](https://googlecontainertools.github.io/kpt/guides/producer/blueprint/).

- [Cloud Build trigger](https://cloud.google.com/cloud-build/docs/automating-builds/create-manage-triggers)
  - After source repo changes are pushed/ merged, if your contents are a [blueprint](https://googlecontainertools.github.io/kpt/guides/producer/blueprint/),then Cloud Build will perform hydration and validation using your specified kpt functions. This is a no-op if you are using plain KRM. Changes are then pushed to the deployment repo under the `config` folder to be applied to the Yakima cluster by Config Sync.

- Deployment repo (WET) w/ deploy key configured
  - After source repo changes are made, this is where hydrated configurations are pushed to and applied to your cluster via Config Sync.

- Various IAM policy bindings and GSA for cloud build to access the repositories + for Config Sync to be able to sync from the deployment repo.

### To apply the blueprint:
1. Navigate to your workspace and list your setters using

   ```
   kpt cfg list-setters csr-git-ops-pipeline/
   ```
2. Change fields as needed (i.e. `project-id`, `region`, etc) using
   ```
   kpt cfg set ${SETTER_NAME} ${VALUE}
   ```
3. Apply your blueprint using
   ```
   kubectl apply -f csr-git-ops-pipeline/
   ```
4. Annotate the config management importer account
   ```
   kubectl annotate serviceaccount -n config-management-system importer \
        "iam.gke.io/gcp-service-account=${PROJECT_NUMBER}-compute@developer.gserviceaccount.com"
   ```

## FAQS:
- Can I apply this blueprint entirely declaratively (i.e. can I somehow do step 4 in config?
  - Currently, there is a restriction for Cloud Source Repositories to work with Config Sync where an annotation needs to be applied to a KSA that is generated on the fly. This is preventing this blueprint from being fully declarative. This is being looked at.

- I applied the blueprint and it didn't work. How can I fix this?
  - Check your project to see if the resources listed above were generated
    - If not, you can dig into kubectl logs on the particular resource to see if there's any error messages. For example:
    ```
    kubectl describe cloudbuildtrigger -n ${K8S_NAMESPACE}
    ```
  - If all the resources have been created, see if pushes to your source repo are triggering a Cloud Build trigger and whether the resulting build is pushing to your deployment repo. Cloud Build logs may give more hints on this.

  - If the deployment repo is being populated with hydrated config, but Config Sync is not applying the config, try debugging using [nomos](https://cloud.google.com/kubernetes-engine/docs/add-on/config-sync/how-to/nomos-command).

- Should this blueprint be used for production?
  - If Cloud Source Repositories fits your needs as a Git provider, then this blueprint may be used to manage your production resources. However, for the time being, it is **not** recommended to use this blueprint as it is mainly meant to be a proof of concept and has not been extensively tested.
