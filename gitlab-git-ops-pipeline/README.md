# GitLab Git Ops Pipeline
## Author
jcwc@

[TOC]

## Prerequisites
- [Terraform](https://www.terraform.io/downloads.html)
- [gcloud](https://cloud.google.com/sdk/gcloud)
- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
  - Installed and contains context for Yakima cluster
- [Git](https://git-scm.com/downloads)
  - Installed and configured with user.email
- Yakima cluster

## Description
This blueprint instantiates a GitLab in-cluster instance within a pre-existing Yakima managed cluster and creates the necessary components for a fully functional Git Ops CI/CD pipeline. After installing the blueprint, you will be able to:
1. Manage your infrastructure via version control.
2. Create merge requests to review changes
3. Manage plain KRM or blueprints and specify kpt functions for GitLab CI to use
   to hydrate/ validate your configs
4. Automatically apply your git repo configs to your Yakima cluster on merge
<!-- ... insert more as needed. -->

The components generated by this blueprint include:
  - [Config Sync](https://cloud.google.com/kubernetes-engine/docs/add-on/config-sync/overview) w/ SSH credentials configured
    - This allows Yakima to apply KRM directly from the deployment repo to the Yakima cluster.
  - Source repo (DRY)
    - This is where your changes will be made. You can push plain KRM or [blueprints](https://googlecontainertools.github.io/kpt/guides/producer/blueprint/).
  - [Gitlab CI configuration](https://docs.gitlab.com/ee/ci/yaml/)
    - After source repo changes are pushed/ merged, if your contents are a [blueprint](https://googlecontainertools.github.io/kpt/guides/producer/blueprint/), then GitLab CI will perform hydration and validation using your specified kpt functions. This is a no-op if you are using plain KRM. Changes are then pushed to the deployment repo under the `config` folder to be applied to the Yakima cluster by Config Sync.
  - Deployment repo (WET) w/ deploy key configured
    - After source repo changes are made, this is where hydrated configurations are pushed to and applied to your cluster via Config Sync.


### To apply the blueprint
1. Navigate to `gitlab-in-cluster` folder: `cd gitlab-in-cluster`
   1. Create a `terraform.tfvars` file and configure the file.
      1. You can refer to `example.tfvars` for example usage and
         `variables.tfvars` as documentation reference.
   2. Run `terraform init && terraform plan` to preview your changes.
   3. Run `terraform apply` to apply your changes.
   4. Your GitLab instance has been created. Login with the credentials provided
      in the GitLab output to modify your repo however you see fit.
      1. Keep track of your `personal_access_token`. You will need it later.
2. Navigate to `git-ops-pipeline` folder: `cd ../git-ops-pipeline`
   1. Create a `terraform.tfvars` file and configure the file.
      1. You can refer to `example.tfvars` for example usage and
         `variables.tfvars` as documentation reference.
      2. Personal access token can be obtained from the output of the previous
         `terraform apply` command output or by running
         `terraform output personal_access_token` in the `gitlab-in-cluster`
         folder
   2. Run `terraform init && terraform plan` to preview your changes.
   3. Run `terraform apply` to apply your changes.
   4. Use the outputs from the apply command to apply changes to your source
      repo. It will be passed through the git ops pipeline and applied using
      Yakima.

*Note: the above steps can be ran without using `terraform.tfvars` but will need
command line inputs.*

### Making your first git ops change
1. Set your environment variables
   ```bash
   cd gitlab-git-ops-pipeline/git-ops-pipeline
   GITLAB_URL=$(terraform output gitlab_url)
   SOURCE_REPO_CLONE_URL=$(terraform output source_repo_clone_url)
   CI_PIPELINE_URL=$(terraform output ci_pipeline_url)
   PROJECT_ID=<your project ID>
   ```

2. Clone your source repo
   ```bash
   git clone ${SOURCE_REPO_CLONE_URL}
   # You can run an `ls` to see your cloned source repo name
   cd ${SOURCE_REPO_NAME}
   ```

3. (Optional) Create a branch called "staging" to make config changes, hydrate them and validate them without applying them via Yakima.
   ```bash
   git checkout -b staging
   git push --set-upstream origin staging
   ```

4. Add a sample config to your cloned source repo. If you would like to use our sample config, you can run the following:
   ```bash
   kpt pkg get sso://cnrm/blueprints.git/redis-sample@master .
   kpt cfg list-setters redis-sample
   # YAKIMA_NAMESPACE is set to your project ID by default when creating a Yakima instance
   kpt cfg set redis-sample namespace ${YAKIMA_NAMESPACE}
   kpt cfg set redis-sample project-id ${PROJECT_ID}
   # ... set other fields as desired
   ```

5. Commit and push your changes from your repo with the following commands:
   ```bash
   git add -A
   git commit -m "My first Git Ops commit"
   git push
   ```

6. Monitor your changes on GitLab CI on the UI of your GitLab instance. You can also view the hydrated KRM in your deployment repo if the build is successful.
   ```bash
   echo "See your repos in the GitLab UI: ${GITLAB_URL}"
   echo "See your GitLab CI changes: ${CI_PIPELINE_URL}"
   ```

7. (Optional) If you performed step 2, you can merge your changes to master when you feel comfortable with Yakima actuating the resources in your cluster/ GCP account.
   ```bash
   git checkout master
   git merge staging
   git push
   ```

8. (Optional) Run step 5 again to see the results of your build.

9.  Use [nomos](https://cloud.google.com/kubernetes-engine/docs/add-on/config-sync/how-to/nomos-command) (`nomos status`) to check on the sync state of your Yakima cluster against the deployment repo.

10. Confirm resources are created. If you used our sample config, you should see a Redis Instance in GCP Memorystore

### Undoing your git ops change
TODO

## FAQS
- Is there a single command to run this blueprint?
  - This is a WIP

- I applied the blueprint and got into a partial state and it failed. What
  should I do?
  - Attempt to re-apply the failed blueprint first and see if it works.
  - If you have conflicting resources that already exist, see if the tfvars
    can be modified to avoid the conflict. If not, try manually deleting the
    pre-existing resources or
    [importing them to Terraform](https://www.terraform.io/docs/import/index.html).
  - Since certain parts of the blueprint are done imperatively via
    [Terraform provisioners](https://www.terraform.io/docs/provisioners/index.html),
    sometimes, the only option is to delete the rogue resources and retry
    creation. Some things that may need manual attention are:
    - Deleting `git-creds` secret in the `config-management-system` namespace
      - `kubectl delete secret git-creds -n config-management-system`
    <!-- ... insert more as we find them -->

- Should this blueprint be used for production?
  - At the moment, it is **not** recommended to use this blueprint for production. The contents of this blueprint is meant to be a proof of concept and will not scale with production workloads. In the future, we will be making iterations to make the blueprint more production friendly.
