# CSR Git Ops Pipeline
## Author
jcwc@

[TOC]

## Prerequisites
- Yakima cluster (set as current-context for kubectl)
- [kubectl](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
  - Installed and contains context for Yakima cluster
- [kpt](https://googlecontainertools.github.io/kpt/guides/)

## Description
This blueprint instantiates a Git Ops CI/CD pipeline using Cloud Source Repositories and Cloud Build. After installing this blueprint, you will be able to:
1. Manage your infrastructure via version control.
2. Create merge requests to review changes
3. Manage plain KRM or blueprints and specify kpt functions for Cloud Build to use to hydrate/ validate your configs
4. Automatically apply your git repo configs to your Yakima cluster on merge
<!-- ... insert more as needed. -->

The components generated by this blueprint include:
- [Config Sync](https://cloud.google.com/kubernetes-engine/docs/add-on/config-sync/overview) w/ gcenode secret configured
 - This allows Yakima to apply KRM directly from the deployment repo to the Yakima cluster.

- Source repo (DRY)
  - This is where your changes will be made. You can push plain KRM or [blueprints](https://googlecontainertools.github.io/kpt/guides/producer/blueprint/).

- [Cloud Build trigger](https://cloud.google.com/cloud-build/docs/automating-builds/create-manage-triggers)
  - After source repo changes are pushed/ merged, if your contents are a [blueprint](https://googlecontainertools.github.io/kpt/guides/producer/blueprint/),then Cloud Build will perform hydration and validation using your specified kpt functions. This is a no-op if you are using plain KRM. Changes are then pushed to the deployment repo under the `config` folder to be applied to the Yakima cluster by Config Sync.

- Deployment repo (WET) w/ deploy key configured
  - After source repo changes are made, this is where hydrated configurations are pushed to and applied to your cluster via Config Sync.

- Various IAM policy bindings and GSA for cloud build to access the repositories + for Config Sync to be able to sync from the deployment repo.

### To apply the blueprint
1. Navigate to your workspace and list your setters using
   ```bash
   kpt cfg list-setters csr-git-ops-pipeline/
   ```

2. Change fields as needed (i.e. `project-id`, `region`, etc) using
   ```bash
   kpt cfg set ${SETTER_NAME} ${VALUE}
   ```

3. Apply your blueprint using
   ```bash
   kubectl apply -f csr-git-ops-pipeline/
   ```

4. Annotate the config management importer account
   ```bash
   kubectl annotate serviceaccount -n config-management-system importer \
        "iam.gke.io/gcp-service-account=${PROJECT_NUMBER}-compute@developer.gserviceaccount.com"
   ```

### Making your first git ops change
1. Clone your source repo
   ```bash
   SOURCE_REPO_NAME=<your source repo>
   PROJECT_ID=<your project id>
   gcloud source repos clone "${SOURCE_REPO_NAME}" --project="${PROJECT_ID}"
   cd ${SOURCE_REPO_NAME}
   ```
   - If you forgot the values for ${SOURCE_REPO_NAME} and ${PROJECT_ID} run `kpt cfg list-setters csr-git-ops-pipeline/` to jog your memory.

2. (Optional) Create a branch called "staging" (or whatever your kpt setter value is set for `staging-branch`) to make config changes, hydrate them and validate them without applying them via Yakima.
   ```bash
   git checkout -b staging
   git push --set-upstream origin staging
   ```

3. Add a sample config to your cloned source repo. If you would like to use our sample config, you can run the following:
   ```bash
   kpt pkg get sso://cnrm/blueprints.git/redis-sample@master .
   kpt cfg list-setters redis-sample
   # YAKIMA_NAMESPACE is set to your project ID by default when creating a Yakima instance
   kpt cfg set redis-sample namespace ${YAKIMA_NAMESPACE}
   kpt cfg set redis-sample project-id ${PROJECT_ID}
   # ... set other fields as desired
   ```

4. Commit and push your changes from your repo with the following commands:
   ```bash
   cd ${SOURCE_REPO_NAME}
   git add -A
   git commit -m "My first Git Ops commit"
   git push
   ```

5. Monitor your changes on Cloud Build. Note you can do this using gcloud or in the [Cloud Build console](https://console.cloud.google.com/cloud-build/builds). You can also view the hydrated KRM in your [deployment repo](https://source.cloud.google.com/) if the build is successful.
   ```bash
   FILTER="source.repo_source.commit_sha=$(git rev-parse HEAD)"
   # You can poll on this command until status is either SUCCESS or FAILURE
   gcloud builds list --project=${PROJECT_ID} --filter=${FILTER}

   BUILD_ID=$(gcloud builds list --project=${PROJECT_ID} --filter=${FILTER} --format='get(id)' | head -n 1)
   # View logs for your run. You can use this to debug errors
   gcloud builds log --project=${PROJECT_ID} $BUILD_ID
   ```

6. (Optional) If you performed step 2, you can merge your changes to master when you feel comfortable with Yakima actuating the resources in your cluster/ GCP account.
   ```bash
   git checkout master
   git merge staging
   git push
   ```

7. (Optional) Run step 5 again to see the results of your build.

8. Use [nomos](https://cloud.google.com/kubernetes-engine/docs/add-on/config-sync/how-to/nomos-command) (`nomos status`) to check on the sync state of your Yakima cluster against the deployment repo.

9.  Confirm resources are created. If you used our sample config, you should see a Redis Instance in GCP Memorystore

### Undoing your git ops change
TODO

## FAQS:
- Can I apply this blueprint entirely declaratively (i.e. can I somehow do step 4 in config?
  - Currently, there is a restriction for Cloud Source Repositories to work with Config Sync where an annotation needs to be applied to a KSA that is generated on the fly. This is preventing this blueprint from being fully declarative. This is being looked at.

- I applied the blueprint and it didn't work. How can I fix this?
  - Check your project to see if the resources listed above were generated
    - If not, you can dig into kubectl logs on the particular resource to see if there's any error messages. For example:
    ```
    kubectl describe cloudbuildtrigger -n ${K8S_NAMESPACE}
    ```
  - If all the resources have been created, see if pushes to your source repo are triggering a Cloud Build trigger and whether the resulting build is pushing to your deployment repo. Cloud Build logs may give more hints on this.

  - If the deployment repo is being populated with hydrated config, but Config Sync is not applying the config, try debugging using [nomos](https://cloud.google.com/kubernetes-engine/docs/add-on/config-sync/how-to/nomos-command).

- Should this blueprint be used for production?
  - If Cloud Source Repositories fits your needs as a Git provider, then this blueprint may be used to manage your production resources. However, for the time being, it is **not** recommended to use this blueprint as it is mainly meant to be a proof of concept and has not been extensively tested.
